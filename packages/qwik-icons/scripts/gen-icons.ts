import * as fs from "fs";
import * as path from "path";

import { startCase } from "lodash-es";
import { Options, format } from "prettier";
import * as Rx from "rxjs";
import * as svgo from "svgo";

import config from "./iconset";

export type IconSetEntry = {
  name: string;
  refer: string;
  prefix: string;
  baseUrl: string;
  icons: string[];
  coloring: "fill" | "stroke" | "keep";
  replaceColor?: string;
};

export type GeneratorConfig = {
  outDir: string;
  entries: IconSetEntry[];
};

/**
 * Prettier format options, see https://prettier.io/docs/en/options.html
 */
const formatOpts: Options = {
  parser: "babel",
};

/**
 * Header
 */
const header = `/**
 * This file was automatically generated by scripts/gen-icons.ts
 **/
import { component$ } from "@builder.io/qwik";
import type { RectIconProps } from "../../utils/index";
`;

/**
 * SVG -> JSX
 */
const generateQwikSvgJsx = ({
  name,
  svg,
  coloring,
  replaceColor,
}: {
  name: string;
  svg: string;
  coloring: "fill" | "stroke" | "keep";
  replaceColor?: string;
}) => {
  console.log("generating", name);
  const otherColoring = coloring === "fill" ? "stroke" : "fill";
  const keepColoring = coloring === "keep";
  const colorAttributes = keepColoring
    ? {}
    : { [coloring]: "currentColor", [otherColoring]: "none" };

  // Replace colors in the original svg if applicable
  const recollored = replaceColor
    ? svg.replaceAll(new RegExp(replaceColor, "g"), "currentColor")
    : svg;

  // Process the svg
  const processed: string = svgo.optimize(recollored, {
    plugins: [
      "removeComments",
      "removeDesc",
      "removeDoctype",
      "removeMetadata",
      "removeEditorsNSData",
      "removeTitle",
      "removeXMLProcInst",
      "removeHiddenElems",
      "removeEmptyContainers",
      {
        name: "addAttributesToSVGElement",
        params: {
          attributes: Object.entries({
            ...colorAttributes,
            width: "1em",
            height: "1em",
            PROPS: "%PROPS_HOLDER%",
            "data-qwik-icon": "",
          }).map(([key, value]) => ({ [key]: value })),
        },
      },
      {
        name: "rewrite",
        fn: () => {
          return {
            element: {
              enter(node) {
                if (node.name === "svg") {
                  node.attributes["width"] = "1em";
                  node.attributes["height"] = "1em";
                }
              },
            },
          };
        },
      },
    ],
  }).data;

  // Add props
  const replaced = processed.replace(`PROPS="%PROPS_HOLDER%"`, "{...props}");

  // Return the component
  return `export const ${name} = component$<RectIconProps>((props) => {\n  return (\n ${replaced})\n})`;
};

/**
 * Fetch the icon and generate the components
 * @param entry
 * @returns
 */
async function generateIconSet(entry: IconSetEntry) {
  const iconSet = Array.from(new Set(entry.icons).keys());
  const result$ = Rx.from(iconSet).pipe(
    Rx.tap((it) => console.log(`fetching ${entry.name}/${it}`)),
    Rx.mergeMap(
      // (it) => Rx.from(fetch(path.join(entry.baseUrl, it + '.svg'))),
      (it) =>
        Rx.zip([
          Rx.of(it),
          Rx.from(fetch(path.join(entry.baseUrl, it + ".svg"))).pipe(
            Rx.mergeMap((it) => it.text()),
            Rx.map((it) => ({ data: it })),
            Rx.catchError((it: Error) => Rx.of({ error: it }))
          ),
        ]),
      100
    ),
    Rx.map(([name, result]) => ({ name, result })),
    Rx.toArray()
  );
  const result = await Rx.lastValueFrom(result$);

  let code = header;
  for (const it of result) {
    if ("error" in it.result) {
      throw new Error(`${entry.name}/${it.name} failed: ${it.result.error}`);
      continue;
    }

    const iconName = entry.prefix + startCase(it.name).replaceAll(" ", "");
    code +=
      generateQwikSvgJsx({
        name: iconName,
        svg: it.result.data,
        coloring: entry.coloring,
        replaceColor: entry.replaceColor,
      }) + "\n";
  }

  const formatted: string = format(code, formatOpts);
  return formatted;
}

/**
 * Build the icons
 * @param config
 */
async function build(config: GeneratorConfig) {
  // Check if the output directory exists and create it if not
  if (!fs.existsSync(config.outDir)) {
    fs.mkdirSync(config.outDir);
  }

  const all = await Promise.all(config.entries.map(generateIconSet));

  for (let i = 0; i < all.length; i++) {
    const it = config.entries[i];
    fs.writeFileSync(`${config.outDir}/${it.name}.tsx`, all[i], "utf-8");
  }
}

build(config);
